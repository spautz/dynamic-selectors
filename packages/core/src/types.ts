/* eslint-disable @typescript-eslint/no-explicit-any */

import type {
  DynamicSelectorDebugInfo,
  DynamicSelectorResultCache,
  DynamicSelectorResultEntry,
} from './internals';

type AnyPrimitive = boolean | number | string | null | undefined;

/**
 * This type alias is for readability only.
 */
export type DefaultReturnType = unknown;

/**
 * This type alias is for readability only.
 * Any state shape is valid, and we can't make assumptions about it.
 */
export type DefaultStateType = any;

/**
 * A lodash.get-style path into State
 */
export type StatePath = number | string | Array<number | string> | null;

/**
 * This type alias is for readability only.
 * Each selector allows any number of additional arguments after the params.
 */
export type DefaultExtraArgsType = Array<any>;

/**
 * Params may be a primitive or a simple set of primitives: a flat object or a simple array. Complex types and
 * deeply-nested objects should not be used as selector params -- just like they shouldn't be used as route params.
 */
export type DynamicSelectorParams =
  | AnyPrimitive
  | Array<AnyPrimitive>
  | Record<string, AnyPrimitive | Array<AnyPrimitive>>;

export type DynamicSelectorStateGetFn<StateType = DefaultStateType> = (
  state: StateType,
  path: StatePath,
  defaultValue?: unknown,
) => unknown;

/**
 * Options for how to interact with the state.
 *
 * State options represent an original source of state -- like Redux, a Context value, or some other 'universe'
 * that we want to transform via a selector.
 */
export type DynamicSelectorStateOptions<StateType = DefaultStateType> = {
  /* State equality checking: if this returns true then the states will be considered the same */
  compareState: (oldState: StateType, newState: StateType) => boolean;
  /* Accessor to retrieve a value from the state */
  get: DynamicSelectorStateGetFn<StateType>;
  /* The base options that will be assigned to each selector (unless overridden when creating the selector) */
  defaultSelectorOptions: DynamicSelectorOptions;
};

/**
 * Options for how an individual selector behaves.
 */
export type DynamicSelectorOptions<
  ReturnType = DefaultReturnType,
  StateType = DefaultStateType,
  ParamsType = DynamicSelectorParams,
  ExtraArgsType extends Array<any> = DefaultExtraArgsType,
> = {
  /* Output equality checking: if this returns true then the selector will be considered unchanged */
  compareResult: (oldReturnValue: ReturnType, newReturnValue: ReturnType) => boolean;
  /* Used to customize the cache of results */
  createResultCache: () => DynamicSelectorResultCache;
  /* Verbose output, useful for debugging the library itself */
  debug?: boolean | string;
  /* Sets the function's displayName */
  displayName?: string;
  /* Generates a unique ID for the selector's params */
  getKeyForParams: (params?: ParamsType) => string;
  /* Called if the selector function throws an exception */
  onError:
    | ((
        error: Error,
        args: [StateType, ParamsType, ...ExtraArgsType],
        selectorFn: DynamicSelectorFnFromTypes,
      ) => void)
    | null;
};

/**
 * The `getState` function that's available within each Dynamic Selector.
 */
export type DynamicSelectorStateAccessor<ReturnType = DefaultReturnType> = <
  InnerReturnType = ReturnType,
>(
  path: number | string | Array<number | string> | null,
  defaultValue?: InnerReturnType,
) => InnerReturnType;

/**
 * The plain, 'inner' function that a Dynamic Selector is created from.
 */
export interface DynamicSelectorInnerFn<StateType = DefaultStateType> {
  (
    getStateFn: DynamicSelectorStateAccessor<StateType>,
    params?: any,
    ...extraArgs: Array<any>
  ): any;
  displayName?: string;
  // eslint-enable @typescript-eslint/no-explicit-any
}

/**
 * Main typing for a dynamic-selector function, autogenerated from the typings of its internal function.
 */
export interface DynamicSelectorFnFromInnerFn<
  StateType,
  InnerFn extends DynamicSelectorInnerFn<any>,
> {
  /** Call signature when invoked from inside another selector: no state argument */
  (...args: RemoveFirstElement<Parameters<InnerFn>>): ReturnType<InnerFn>;
  /** Call signature when invoked from outside any selector: state is first argument */
  (state: StateType, ...args: RemoveFirstElement<Parameters<InnerFn>>): ReturnType<InnerFn>;

  _fn: DynamicSelectorInnerFn<any>; // InnerFn;
  _dc: ReplaceReturnType<ReplaceFirstArg<InnerFn, StateType>, DynamicSelectorResultEntry>;
  _rc: DynamicSelectorResultCache;
  displayName: string;
  getDebugInfo: (params?: DynamicSelectorParams) => DynamicSelectorDebugInfo;
  getCachedResult: {
    /** Call signature when invoked from inside another selector: no state argument */
    (...args: RemoveFirstElement<Parameters<InnerFn>>): ReturnType<InnerFn> | undefined;
    /** Call signature when invoked from outside any selector: state is first argument */
    (state: StateType, ...args: RemoveFirstElement<Parameters<InnerFn>>):
      | ReturnType<InnerFn>
      | undefined;
  };
  hasCachedResult: {
    /** Call signature when invoked from inside another selector: no state argument */
    (...args: RemoveFirstElement<Parameters<InnerFn>>): boolean;
    /** Call signature when invoked from outside any selector: state is first argument */
    (state: StateType, ...args: RemoveFirstElement<Parameters<InnerFn>>): boolean;
  };
  isDynamicSelector: true;
  resetCache: () => void;
}

export type DynamicSelectorFnFromTypes<
  ReturnType = DefaultReturnType,
  StateType = DefaultStateType,
  ParamsType = DynamicSelectorParams,
  ExtraArgsType extends Array<any> = DefaultExtraArgsType,
> = DynamicSelectorFnFromInnerFn<
  StateType,
  undefined extends ParamsType
    ? (
        getStateFn: DynamicSelectorStateAccessor<StateType>,
        params?: ParamsType,
        ...extraArgs: ExtraArgsType | any
      ) => ReturnType
    : (
        getStateFn: DynamicSelectorStateAccessor<StateType>,
        params: ParamsType,
        ...extraArgs: ExtraArgsType | any
      ) => ReturnType
>;

export type AnyDynamicSelectorFn = DynamicSelectorFnFromTypes<any, any, any, Array<any>>;

export type RemoveFirstElement<List extends Array<unknown>> = List extends [
  infer _FirstType,
  ...infer AllTypesAfterFirst,
]
  ? AllTypesAfterFirst
  : [];

export type RemoveFirstArg<FnType extends (firstArg: any, ...otherArgs: any) => any> = (
  ...args: RemoveFirstElement<Parameters<FnType>>
) => ReturnType<FnType>;

export type ReplaceFirstArg<
  FnType extends (firstArg: any, ...otherArgs: any) => any,
  NewFirstArgType,
> = (
  firstArg: NewFirstArgType,
  ...args: RemoveFirstElement<Parameters<FnType>>
) => ReturnType<FnType>;

export type ReplaceReturnType<FnType extends (...args: any) => any, NewReturnType> = (
  ...args: Parameters<FnType>
) => NewReturnType;
